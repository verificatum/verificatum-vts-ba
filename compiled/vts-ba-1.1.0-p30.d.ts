/**
 * Subset of non-negative integers.
 */
export declare type S1 = 1;
/**
 * Subset of non-negative integers.
 */
export declare type S2 = S1 | 2;
/**
 * Subset of non-negative integers.
 */
export declare type S3 = S2 | 3;
/**
 * Subset of non-negative integers.
 */
export declare type S4 = S3 | 4;
/**
 * Subset of non-negative integers.
 */
export declare type S5 = S4 | 5;
/**
 * Subset of non-negative integers.
 */
export declare type S6 = S5 | 6;
/**
 * Subset of non-negative integers.
 */
export declare type S7 = S6 | 7;
/**
 * Subset of non-negative integers.
 */
export declare type S8 = S7 | 8;
/**
 * Subset of non-negative integers.
 */
export declare type S9 = S8 | 9;
/**
 * Subset of non-negative integers.
 */
export declare type S10 = S9 | 10;
/**
 * Subset of non-negative integers.
 */
export declare type S11 = S10 | 11;
/**
 * Subset of non-negative integers.
 */
export declare type S12 = S11 | 12;
/**
 * Subset of non-negative integers.
 */
export declare type S13 = S12 | 13;
/**
 * Subset of non-negative integers.
 */
export declare type S14 = S13 | 14;
/**
 * Subset of non-negative integers.
 */
export declare type S15 = S14 | 15;
/**
 * Subset of non-negative integers.
 */
export declare type S16 = S15 | 16;
/**
 * Subset of non-negative integers.
 */
export declare type S17 = S16 | 17;
/**
 * Subset of non-negative integers.
 */
export declare type S18 = S17 | 18;
/**
 * Subset of non-negative integers.
 */
export declare type S19 = S18 | 19;
/**
 * Subset of non-negative integers.
 */
export declare type S20 = S19 | 20;
/**
 * Subset of non-negative integers.
 */
export declare type S21 = S20 | 21;
/**
 * Subset of non-negative integers.
 */
export declare type S22 = S21 | 22;
/**
 * Subset of non-negative integers.
 */
export declare type S23 = S22 | 23;
/**
 * Subset of non-negative integers.
 */
export declare type S24 = S23 | 24;
/**
 * Subset of non-negative integers.
 */
export declare type S25 = S24 | 25;
/**
 * Subset of non-negative integers.
 */
export declare type S26 = S25 | 26;
/**
 * Subset of non-negative integers.
 */
export declare type S27 = S26 | 27;
/**
 * Subset of non-negative integers.
 */
export declare type S28 = S27 | 28;
/**
 * Subset of non-negative integers.
 */
export declare type S29 = S28 | 29;
/**
 * Subset of non-negative integers.
 */
export declare type S30 = S29 | 30;
/**
 * Subset of non-negative integers.
 */
export declare type S31 = S30 | 31;
/**
 * Subset of non-negative integers.
 */
export declare type S32 = S31 | 32;
/**
 * Subset of non-negative integers.
 */
export declare type S33 = S32 | 33;
/**
 * Subset of non-negative integers.
 */
export declare type S34 = S33 | 34;
/**
 * Subset of non-negative integers.
 */
export declare type S35 = S34 | 35;
/**
 * Subset of non-negative integers.
 */
export declare type S36 = S35 | 36;
/**
 * Subset of non-negative integers.
 */
export declare type S37 = S36 | 37;
/**
 * Subset of non-negative integers.
 */
export declare type S38 = S37 | 38;
/**
 * Subset of non-negative integers.
 */
export declare type S39 = S38 | 39;
/**
 * Subset of non-negative integers.
 */
export declare type S40 = S39 | 40;
/**
 * Subset of non-negative integers.
 */
export declare type S41 = S40 | 41;
/**
 * Subset of non-negative integers.
 */
export declare type S42 = S41 | 42;
/**
 * Subset of non-negative integers.
 */
export declare type S43 = S42 | 43;
/**
 * Subset of non-negative integers.
 */
export declare type S44 = S43 | 44;
/**
 * Subset of non-negative integers.
 */
export declare type S45 = S44 | 45;
/**
 * Subset of non-negative integers.
 */
export declare type S46 = S45 | 46;
/**
 * Subset of non-negative integers.
 */
export declare type S47 = S46 | 47;
/**
 * Subset of non-negative integers.
 */
export declare type S48 = S47 | 48;
/**
 * Subset of non-negative integers.
 */
export declare type S49 = S48 | 49;
/**
 * Subset of non-negative integers.
 */
export declare type S50 = S49 | 50;
/**
 * Subset of non-negative integers.
 */
export declare type S51 = S50 | 51;
/**
 * Subset of non-negative integers.
 */
export declare type S52 = S51 | 52;
/**
 * Subset of non-negative integers.
 */
export declare type S53 = S52 | 53;
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint1_brand {
    __ubrand__ ? : S1;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint2_brand {
    __ubrand__ ? : S2;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint3_brand {
    __ubrand__ ? : S3;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint4_brand {
    __ubrand__ ? : S4;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint5_brand {
    __ubrand__ ? : S5;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint6_brand {
    __ubrand__ ? : S6;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint7_brand {
    __ubrand__ ? : S7;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint8_brand {
    __ubrand__ ? : S8;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint9_brand {
    __ubrand__ ? : S9;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint10_brand {
    __ubrand__ ? : S10;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint11_brand {
    __ubrand__ ? : S11;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint12_brand {
    __ubrand__ ? : S12;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint13_brand {
    __ubrand__ ? : S13;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint14_brand {
    __ubrand__ ? : S14;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint15_brand {
    __ubrand__ ? : S15;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint16_brand {
    __ubrand__ ? : S16;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint17_brand {
    __ubrand__ ? : S17;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint18_brand {
    __ubrand__ ? : S18;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint19_brand {
    __ubrand__ ? : S19;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint20_brand {
    __ubrand__ ? : S20;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint21_brand {
    __ubrand__ ? : S21;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint22_brand {
    __ubrand__ ? : S22;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint23_brand {
    __ubrand__ ? : S23;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint24_brand {
    __ubrand__ ? : S24;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint25_brand {
    __ubrand__ ? : S25;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint26_brand {
    __ubrand__ ? : S26;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint27_brand {
    __ubrand__ ? : S27;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint28_brand {
    __ubrand__ ? : S28;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint29_brand {
    __ubrand__ ? : S29;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint30_brand {
    __ubrand__ ? : S30;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint31_brand {
    __ubrand__ ? : S31;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint32_brand {
    __ubrand__ ? : S32;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint33_brand {
    __ubrand__ ? : S33;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint34_brand {
    __ubrand__ ? : S34;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint35_brand {
    __ubrand__ ? : S35;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint36_brand {
    __ubrand__ ? : S36;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint37_brand {
    __ubrand__ ? : S37;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint38_brand {
    __ubrand__ ? : S38;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint39_brand {
    __ubrand__ ? : S39;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint40_brand {
    __ubrand__ ? : S40;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint41_brand {
    __ubrand__ ? : S41;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint42_brand {
    __ubrand__ ? : S42;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint43_brand {
    __ubrand__ ? : S43;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint44_brand {
    __ubrand__ ? : S44;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint45_brand {
    __ubrand__ ? : S45;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint46_brand {
    __ubrand__ ? : S46;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint47_brand {
    __ubrand__ ? : S47;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint48_brand {
    __ubrand__ ? : S48;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint49_brand {
    __ubrand__ ? : S49;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint50_brand {
    __ubrand__ ? : S50;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint51_brand {
    __ubrand__ ? : S51;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint52_brand {
    __ubrand__ ? : S52;
}
/**
 * Brand for construction of branded unsigned integer type.
 */
export interface uint53_brand {
    __ubrand__ ? : S53;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int2_brand {
    __ubrand__ ? : S2;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int3_brand {
    __ubrand__ ? : S3;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int4_brand {
    __ubrand__ ? : S4;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int5_brand {
    __ubrand__ ? : S5;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int6_brand {
    __ubrand__ ? : S6;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int7_brand {
    __ubrand__ ? : S7;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int8_brand {
    __ibrand__ ? : S8;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int9_brand {
    __ibrand__ ? : S9;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int10_brand {
    __ibrand__ ? : S10;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int11_brand {
    __ibrand__ ? : S11;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int12_brand {
    __ibrand__ ? : S12;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int13_brand {
    __ibrand__ ? : S13;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int14_brand {
    __ibrand__ ? : S14;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int15_brand {
    __ibrand__ ? : S15;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int16_brand {
    __ibrand__ ? : S16;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int17_brand {
    __ibrand__ ? : S17;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int18_brand {
    __ibrand__ ? : S18;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int19_brand {
    __ibrand__ ? : S19;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int20_brand {
    __ibrand__ ? : S20;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int21_brand {
    __ibrand__ ? : S21;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int22_brand {
    __ibrand__ ? : S22;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int23_brand {
    __ibrand__ ? : S23;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int24_brand {
    __ibrand__ ? : S24;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int25_brand {
    __ibrand__ ? : S25;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int26_brand {
    __ibrand__ ? : S26;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int27_brand {
    __ibrand__ ? : S27;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int28_brand {
    __ibrand__ ? : S28;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int29_brand {
    __ibrand__ ? : S29;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int30_brand {
    __ibrand__ ? : S30;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int31_brand {
    __ibrand__ ? : S31;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int32_brand {
    __ibrand__ ? : S32;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int33_brand {
    __ibrand__ ? : S33;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int34_brand {
    __ibrand__ ? : S34;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int35_brand {
    __ibrand__ ? : S35;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int36_brand {
    __ibrand__ ? : S36;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int37_brand {
    __ibrand__ ? : S37;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int38_brand {
    __ibrand__ ? : S38;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int39_brand {
    __ibrand__ ? : S39;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int40_brand {
    __ibrand__ ? : S40;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int41_brand {
    __ibrand__ ? : S41;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int42_brand {
    __ibrand__ ? : S42;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int43_brand {
    __ibrand__ ? : S43;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int44_brand {
    __ibrand__ ? : S44;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int45_brand {
    __ibrand__ ? : S45;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int46_brand {
    __ibrand__ ? : S46;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int47_brand {
    __ibrand__ ? : S47;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int48_brand {
    __ibrand__ ? : S48;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int49_brand {
    __ibrand__ ? : S49;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int50_brand {
    __ibrand__ ? : S50;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int51_brand {
    __ibrand__ ? : S51;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int52_brand {
    __ibrand__ ? : S52;
}
/**
 * Brand for construction of branded signed integer type.
 */
export interface int53_brand {
    __ibrand__ ? : S53;
}
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint1_t = number & uint1_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint2_t = number & uint2_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint3_t = number & uint3_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint4_t = number & uint4_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint5_t = number & uint5_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint6_t = number & uint6_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint7_t = number & uint7_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint8_t = number & uint8_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint9_t = number & uint9_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint10_t = number & uint10_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint11_t = number & uint11_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint12_t = number & uint12_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint13_t = number & uint13_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint14_t = number & uint14_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint15_t = number & uint15_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint16_t = number & uint16_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint17_t = number & uint17_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint18_t = number & uint18_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint19_t = number & uint19_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint20_t = number & uint20_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint21_t = number & uint21_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint22_t = number & uint22_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint23_t = number & uint23_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint24_t = number & uint24_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint25_t = number & uint25_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint26_t = number & uint26_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint27_t = number & uint27_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint28_t = number & uint28_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint29_t = number & uint29_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint30_t = number & uint30_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint31_t = number & uint31_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint32_t = number & uint32_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint33_t = number & uint33_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint34_t = number & uint34_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint35_t = number & uint35_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint36_t = number & uint36_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint37_t = number & uint37_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint38_t = number & uint38_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint39_t = number & uint39_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint40_t = number & uint40_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint41_t = number & uint41_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint42_t = number & uint42_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint43_t = number & uint43_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint44_t = number & uint44_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint45_t = number & uint45_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint46_t = number & uint46_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint47_t = number & uint47_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint48_t = number & uint48_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint49_t = number & uint49_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint50_t = number & uint50_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint51_t = number & uint51_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint52_t = number & uint52_brand;
/**
 * Unsigned "branded" integer type which allows implicit upward cast.
 */
export declare type uint53_t = number & uint53_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int2_t = number & int2_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int3_t = number & int3_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int4_t = number & int4_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int5_t = number & int5_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int6_t = number & int6_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int7_t = number & int7_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int8_t = number & int8_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int9_t = number & int9_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int10_t = number & int10_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int11_t = number & int11_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int12_t = number & int12_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int13_t = number & int13_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int14_t = number & int14_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int15_t = number & int15_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int16_t = number & int16_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int17_t = number & int17_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int18_t = number & int18_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int19_t = number & int19_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int20_t = number & int20_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int21_t = number & int21_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int22_t = number & int22_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int23_t = number & int23_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int24_t = number & int24_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int25_t = number & int25_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int26_t = number & int26_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int27_t = number & int27_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int28_t = number & int28_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int29_t = number & int29_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int30_t = number & int30_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int31_t = number & int31_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int32_t = number & int32_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int33_t = number & int33_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int34_t = number & int34_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int35_t = number & int35_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int36_t = number & int36_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int37_t = number & int37_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int38_t = number & int38_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int39_t = number & int39_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int40_t = number & int40_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int41_t = number & int41_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int42_t = number & int42_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int43_t = number & int43_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int44_t = number & int44_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int45_t = number & int45_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int46_t = number & int46_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int47_t = number & int47_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int48_t = number & int48_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int49_t = number & int49_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int50_t = number & int50_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int51_t = number & int51_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int52_t = number & int52_brand;
/**
 * Signed "branded" integer type which allows implicit upward cast.
 */
export declare type int53_t = number & int53_brand;
/**
 * Pointer/index to memory cell in WASM engine.
 */
export declare type ptr_t = int32_t;
/**
 * Hexadecimal string.
 */
export declare type hex_t = string;
/**
 * Floating point number, i.e., JavaScript "number".
 */
export declare type float64_t = number;
/**
 * Binary integer type.
 */
export declare type bin_t = 0 | 1;
/**
 * Sign as an integer.
 */
export declare type sign_t = -1 | 0 | 1;
/**
 * Radix of a non-negative integer in [2,64].
 */
export declare type radix_t = 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 | 20 | 22 | 24 | 26 | 28 | 30 | 32 | 34 | 36 | 38 | 40 | 42 | 44 | 46 | 48 | 50 | 52 | 54 | 56 | 58 | 60 | 62 | 64;
/**
 * Non-negative integer used as size of arrays.
 */
export declare type size_t = uint32_t;
/**
 * Word of large integer. This is instantiated by an integer type
 * during compilation.
 */
export declare type word_t = uint30_t;
/**
 * Raw representation of large integer consisting of multiple
 * words. Whether it is an integer in two's complement or not is
 * determined by the context.
 */
export declare type uli_t = word_t[];
/**
 * Word of large integer, plus one bit in size. This is instantiated
 * by an integer type during compilation.
 */
export declare type word_a1_t = uint31_t;
/**
 * Word of large integer, plus two bits in size. This is instantiated
 * by an integer type during compilation.
 */
export declare type word_a2_t = uint32_t;
/**
 * Half a word of a large integer. This is instantiated by an integer
 * type during compilation.
 */
export declare type half_t = uint15_t;
/**
 * Half a word of a large integer, plus one bit in size. This is
 * instantiated by an integer type during compilation.
 */
export declare type half_a1_t = uint16_t;
export declare namespace verificatum {
    namespace base {
        const version: string;
        /**
         * Base class for all objects in the library.
         */
        class VerificatumObject {
            /**
             * Returns the name of this class.
             *
             * @returns Name of this class.
             */
            getName(): string;
        }
        /**
         * Abstract random source for cryptographic use.
         */
        abstract class RandomSource {
            /**
             * Returns bytes from the underlying source of randomness.
             *
             * @param len - Number of bytes to generate.
             * @returns Array of random bytes.
             */
            protected abstract getRandomUint8Array(len: size_t): Uint8Array;
            /**
             * Generates the given non-negative number of random bytes.
             *
             * @param len - Number of bytes to generate.
             */
            getBytes(len: size_t): uint8_t[];
        }
        /**
         * Utility classes and functions.
         * TSDOC_MODULE
         */
        /**
         * Integer division rounded towards -infinity.
         *
         * @param n - Numerator.
         * @param d - Divisor.
         */
        function divide(n: int32_t, d: int32_t): int32_t;
        /**
         * Tests if an object is an instance of the given class.
         *
         * @param obj - Object to test.
         * @param type - Class.
         * @returns True or false depending on the object is an instance of
         * the class or not.
         */
        function ofClass(obj: any, atype: any): boolean;
        /**
         * Tests if an object is an instance of the given class, or a a
         * subclass of the given class.
         *
         * @param obj - Object to test.
         * @param atype - Class.
         * @returns True or false.
         */
        function ofSubclass(obj: any, atype: any): boolean;
        /**
         * Tests if an object is an instance of the given class, array, or
         * primitive type.
         *
         * @param obj - Object to test.
         * @param atype - Class, "array", or a string admissable to the typeof
         * operator.
         * @returns True or false.
         */
        function ofType(obj: any, atype: any): boolean;
        /**
         * Verifies that an array of numbers is an array of bytes.
         *
         * @param value - Array to be verified.
         * @returns True or false depending on if the array is a byte array or
         * not.
         */
        function isByteArray(value: number[]): boolean;
        /**
         * Verifies that a string is a hexadecimal string.
         *
         * @param value - String to be verified.
         * @returns True or false depending on if the string is hexadecimal or
         * not.
         */
        function isHexString(value: string): boolean;
        /**
         * Creates a list filled with the same value.
         *
         * @param value - Value to be repeated.
         * @param width - Number of repetitions.
         * @returns List containing the value.
         */
        function fill < T > (value: T, width: size_t): T[];
        /**
         * Creates a list filled with the same value or the value
         * itself if a single repetition is requested.
         *
         * @param value - Value to be repeated.
         * @param width - Number of repetitions.
         * @returns List containing the value or the value itself if width == 1.
         */
        function full < T > (value: T, width ? : size_t): T | T[];

        function hexbyte(b: uint8_t): string;
        /**
         * Converts an ASCII string to a byte array.
         *
         * @param ascii - ASCII string.
         * @returns Corresponding byte array.
         */
        function asciiToByteArray(ascii: string): uint8_t[];
        /**
         * Returns the input if it is already a byte array and converts it to
         * a byte array from an ASCII string otherwise.
         *
         * @param data - Data.
         * @returns Corresponding byte array.
         */
        function asByteArray(data: string | uint8_t[]): uint8_t[];
        /**
         * Converts byte array to ASCII string.
         *
         * @param bytes - Input bytes.
         * @returns ASCII string corresponding to the input.
         */
        function byteArrayToAscii(bytes: uint8_t[]): string;
        /**
         * Converts a byte array to its hexadecimal encoding.
         *
         * @param bytes - Input byte array.
         * @returns Hexadecimal representation of this array.
         */
        function byteArrayToHex(bytes: uint8_t[]): hex_t;
        /**
         * Converts a hexadecimal encoding of a byte array to the
         * byte array.
         *
         * @param hex - Hexadecimal encoding of byte array.
         * @returns Byte array corresponding to the input.
         */
        function hexToByteArray(hex: string): uint8_t[];
        /**
         * Returns the input if it is already a byte array and converts it to
         * a byte array from an hexadecimal encoding otherwise.
         *
         * @param data - Data.
         * @returns Corresponding byte array.
         */
        function hexAsByteArray(data: hex_t | uint8_t[]): uint8_t[];

        function hexToArrayBuffer(hex: string): ArrayBuffer;
        /**
         * Returns true or false depending on if the two input
         * arrays hold identical elements or not.
         *
         * @param x - Array of elements.
         * @param y - Array of elements.
         * @returns Value of boolean equality predicate for arrays.
         */
        function equalsArray(x: uint8_t[], y: uint8_t[]): boolean;
        /**
         * Reads a 32-bit integer in little-endian byte order
         * from the given byte array.
         *
         * @param bytes - Source of bytes.
         * @param index - Offset for reading.
         */
        function readUint32FromByteArray(bytes: uint8_t[], index ? : size_t): uint32_t;
        /**
         * Writes a 32-bit integer in little-endian byte order.
         *
         * @param destination - Destination of result.
         * @param value - Value to write.
         * @param index - Offset for writing.
         */
        function setUint32ToByteArray(destination: uint8_t[], value: uint32_t, index: size_t): void;
        /**
         * Reads a 16-bit integer in little-endian byte order
         * from the given byte array.
         *
         * @param bytes - Source of bytes.
         * @param index - Offset for reading.
         */
        function readUint16FromByteArray(bytes: uint8_t[], index: size_t): uint16_t;
        /**
         * Writes a 16-bit integer in little-endian byte order.
         *
         * @param destination - Destination of result.
         * @param value - Value to write.
         * @param index - Offset for writing.
         */
        function setUint16ToByteArray(destination: uint8_t[], value: uint16_t, index: size_t): void;
    }
    namespace arithm {
        namespace uli {
            import RandomSource = verificatum.base.RandomSource;
            /**
             * Provides the core large integer arithmetic routines needed to
             * implement multiplicative groups and elliptic curve groups over
             * prime order fields. No additional functionality is provided.
             * Although the main goal of this module is to be well-documented and
             * clearly structured with proper encapsulation and without hidden
             * assumptions, this is quite hard in a few routines.
             *
             * <p>
             *
             * WARNING! This module must be used with care due to the assumptions
             * made by routines on inputs, but these assumptions are stated
             * explicitly for each function, so the code is easy to follow.
             *
             * <p>
             *
             * Integers are represented as arrays of numbers constrained to
             * WORDSIZE bits, where WORDSIZE is any even number between 2 and 30
             * (inclusive) and there are hardcoded constants derived from this
             * when the script is generated, so do not attempt to change the
             * wordsize in the generated code. These wordsizes are natural since
             * JavaScript only allows bit operations on signed 32-bit integers. To
             * see this, note that although we can do arithmetic on floating point
             * numbers, e.g., by setting WORDSIZE = 24 we could do multiplications
             * directly, it is expensive to recover parts of the result. Bit
             * operations on 32-bit integers are provided in Javascript, but they
             * are implemented on top of the native "number" datatype, i.e.,
             * numbers are cast (with sign) to 32-bit signed integers, the bit
             * operation is applied, and the result is cast back to a "number".
             *
             * <p>
             *
             * Using small wordsizes exposes certain types of arithmetic bugs, so
             * providing this is not merely for educational purposes, it is also
             * to lower the risk of structural bugs.
             *
             * <p>
             *
             * Functions are mainly implemented for unsigned integers and when
             * called from external functions they assume that any result
             * parameter is of a given length. Some routines deal with integers
             * interpreted in variable length htwo's complement. All arithmetic
             * functions guarantee that any leading unused words are set to zero.
             *
             * <p>
             *
             * A "limb" is an element of an array that may or may not store any
             * single-precision integer. A word is a limb containing data, which
             * may be zero if there are limbs at higher indices holding
             * data. Thus, the number of limbs is the length of an array and the
             * number of words is the index of the most significant word in the
             * array plus one. We make sure to hint to the engine to avoid using
             * sparse arrays by always initializing all elements.
             *
             * <p>
             *
             * The workhorse routine is muladd_loop() which is generated for a
             * given fixed wordsize. This routine determines the speed of
             * multiplication, squaring, division, and exponentiation. For
             * division div3by2() also plays an important role. These routines are
             * generated from M4 macro code to allow using hard coded wordsize
             * dependent constants for increased speed.
             *
             * <p>
             *
             * The M4 macros improve readability, make the code more robust, and
             * simplify experimentation much like snippets of assembler code do in
             * compiled code.
             *
             * <p>
             *
             * JavaScript is inherently difficult to optimize, since the
             * JavaScript engines hot-spot optimize and are moving
             * targets. However, it seems that the built-in arrays in Javascript
             * are faster than the new typed arrays if they are handled
             * properly.
             *
             * <p>
             *
             * One notable observation is that it sometimes makes sense to inform
             * the engine that a JavaScript "number" / float is really a 32-bit
             * integer by saying, e.g., (x | 0) even if we are guaranteed that x
             * is a 32-bit integer. This is important when accessing elements from
             * arrays and it seems to prevent the engine from emitting native code
             * that does dynamic type checking.
             *
             * <p>
             *
             * We avoid dynamic memory allocation almost entirely by keeping
             * scratch space as static variables of the functions. This is
             * implemented using immediate function evaluation in JavaScript, but
             * it is encapsulated to reduce complexity, i.e., calling functions
             * remain unaware of this. This approach works well in our
             * applications, since higher level routines work with integers of
             * fixed bit length.
             *
             * <p>
             *
             * The main implemented algorithms are listed below. <a
             * href="http://cacr.uwaterloo.ca/hac">Handbook of Cryptography,
             * Alfred J. Menezes, Paul C. van Oorschot and Scott A. Vanstone
             * (HAC)</a> gives a straightforward introduction to the basic
             * algorithms used and we try to follow their notation for easy
             * reference. Multiplication and squaring uses <a
             * href="https://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba's
             * algorithm (K)</a>. Division exploits ideas from <a
             * href="https://gmplib.org/~tege/division-paper.pdf">Improved
             * division by invariant integers, IEEE Transactions on Computers,
             * Niels Moller and Torbjorn Granlund (MG)</a>. This is needed to
             * implement div3by2() efficiently. Simultaneous and fixed-base
             * exponentiations rely on a generalization for wider inputs from <a
             * href="https://github.com/verificatum/verificatum-gmpmee">GMPMEE
             * (WG)</a>.
             *
             * <pre>
             * REFERENCE      | OPERATION                   | COMMENT
             * HAC 14.7       | Addition                    | Grade-school
             * HAC 14.9       | Subtraction                 | Grade-school
             * HAC 14.12, K   | Multiplication              | Karatsuba
             * HAC 14.16, K   | Squaring                    | Karatsuba
             * HAC 14.20, MG  | Division                    | Integer reciprocals
             * HAC 14.36      | Montgomery multiplication   | Avoids division
             * HAC 14.82      | Modular exponentiation      | Square and multiply
             * HAC 14.85      | Modular exponentiation      | Sliding window
             * HAC 14.94      | Modular exponentiation      | Montgomery
             * HAC 14.88, WG  | Simultaneous exponentiation | Orthogonal windowing
             * HAC 14.109, WG | Fixed-base exponentiation   | Windowing
             * HAC 4.24       | Primality test              | Miller-Rabin
             * </pre>
             * TSDOC_MODULE
             */
            /**
             * Wordsize in bits, i.e., the number of bits stored in each "number"
             * which make up a big integer.
             */
            const WORDSIZE: size_t;
            /**
             * The value 2^WORDSIZE.
             */
            const TWO_POW_WORDSIZE: size_t;
            /**
             * The word 2^WORDSIZE - 1, i.e., the all-one bit mask.
             */
            const MASK_ALL: size_t;
            /**
             * Indicates if WebAssembly is enabled or not.
             */
            const wasm: boolean;
            /**
             * Maximal number of limbs in an uli_t.
             */
            const MAX_LIMBS: size_t;
            /**
             * Maximum number of bits in an uli_t.
             */
            const MAX_BITS: size_t;
            /**
             * This is a placeholder to allow seamless optional embedding of WASM
             * code.
             */
            function initialize(): void;
            /**
             * Returns the sign extension mask of the given uli.
             *
             * @param x - Integer.
             */
            function sign_mask(x: uli_t): word_t;
            /**
             * Sets x = 0.
             *
             * @param x - Variable.
             */
            function setzero(x: uli_t): void;
            /**
             * Allocates new variable initialized to zero with the given number of
             * limbs.
             *
             * @param limbs - Number of limbs.
             * @returns Zero with the given number of limbs.
             */
            function new_uli(limbs: size_t): uli_t;
            /**
             * Sets w = x with sign extension.
             *
             * <p>
             *
             * ASSUMES: x has fewer words than w has limbs.
             *
             * @param w - Variable.
             * @param x - Signed integer.
             */
            function set(w: uli_t, x: uli_t): void;
            /**
             * Sets w = x without sign extension, i.e., x is interpreted as the
             * least significant word of a non-negative integer.
             *
             * <p>
             *
             * ASSUMES: x has at least two limbs.
             *
             * @param w - Variable.
             * @param x - Value in [0,2^30 - 1].
             */
            function set(w: uli_t, x: word_t): void;
            /**
             * Returns a copy of the input, possibly with additional limbs
             * with sign extension.
             *
             * @param x - Signed integer.
             * @param limbs - Number of limbs in the copy, if larger than the
             * number of limbs in x.
             * @returns Copy of x.
             */
            function copy_uli(x: uli_t, limbs ? : size_t): uli_t;
            /**
             * Returns the index of the most significant word in a non-negative
             * integer.
             *
             * @param x - Unsigned integer.
             * @returns Index of the most significant word in x.
             */
            function msword(x: uli_t, mask ? : word_t): size_t;
            /**
             * Resizes the variable to the smallest number of limbs that represent
             * the same integer in two's complement.
             *
             * @param x - Signed integer.
             */
            function normalize(x: uli_t): void;
            /**
             * Returns a normalized copy of x.
             *
             * @param x - Signed integer.
             */
            function normalized(x: uli_t): uli_t;
            /**
             * Resizes the uli_t to the given number of limbs, either by
             * truncating or by adding leading words with sign extension.
             *
             * @param x - Signed integer.
             * @param limbs - New number of limbs.
             */
            function resize(x: uli_t, limbs: size_t): void;
            /**
             * Returns a uint8_t array representation in two's complement of a
             * normalized integer in two's complement representation.
             *
             * @param x - Integer in two's complement representation.
             * @returns Byte array representation in two's complement of this
             * integer.
             */
            function to_uint8_array(x: uli_t): uint8_t[];
            /**
             * Returns a uli_t representation in two's complement of a normalized
             * uint8_t array in two's complement representation of an integer.
             *
             * @param x - Normalized uint8_t array two's complement representation
             * of an integer.
             * @returns Integer in two's complement representation.
             */
            function from_uint8_array(x: uint8_t[]): uli_t;
            /**
             * Returns a normalized non-negative integer with the given number of
             * nominal random bits.
             *
             * @param bitlen - Nominal number of bits.
             * @param rs - Source of randomness.
             */
            function new_random(bitlen: size_t, rs: RandomSource): uli_t;
            /**
             * Sets w to a non-negative random integer with the given nominal
             * number of bits or as many there is room for in w as a non-negative
             * integer.
             *
             * @param w - Variable.
             * @param bitlen - Nominal number of bits.
             * @param rs - Source of randomness.
             */
            function random(w: uli_t, bitlen: size_t, rs: RandomSource): void;
            /**
             * Sets x = 1.
             *
             * @param x - Variable.
             */
            function setone(x: uli_t): void;
            /**
             * Returns the index of the most significant bit of a non-negative
             * integer x.
             *
             * @param x - Unsigned integer.
             * @returns Index of the most significant bit of x.
             */
            function msbit(x: uli_t): size_t;
            /**
             * Returns the index of a the least significant set bit in a
             * non-negative integer or zero if it is zero.
             *
             * @param x - Unsigned integer.
             * @returns Index of a the least significant set bit in the input or
             * zero if the input is zero.
             */
            function lsbit(x: uli_t): size_t;
            /**
             * Returns 1 or 0 depending on if the bit at the index is set or
             * not. Accessing a bit outside the number of limbs returns the most
             * significant bit.
             *
             * @param x - Signed integer.
             * @param index - Index of bit.
             * @returns Bit at the given position.
             */
            function getbit(x: uli_t, index: size_t): word_t;
            /**
             * Sets a bit to the given value. This may change the sign of x.
             *
             * <p>
             *
             * ASSUMES: 0 <= index < x.length
             *
             * @param x - Signed integer.
             * @param index - Index of bit.
             * @param bit - Bit.
             */
            function setbit(x: uli_t, index: size_t, bit: bin_t): void;
            /**
             * Computes the Hamming weight of x.
             *
             * @param x - Value.
             * @returns Hamming weight of x.
             */
            function weight_word(x: int32_t): uint5_t;
            /**
             * Returns the number of bits set in a non-negative integer.
             *
             * @param x - Signed integer.
             * @returns Bits set in x.
             */
            function weight(x: uli_t): int32_t;
            /**
             * Checks if all elements of the input are zero.
             *
             * @param x - Array of integers.
             * @returns True or false depending on if all elements are zero or not.
             */
            function iszero(x: int32_t[], s ? : size_t): boolean;
            /**
             * Checks if the input is one.
             *
             * @param x - Signed integer.
             */
            function isone(x: uli_t): boolean;
            /**
             * Returns -1, 0, or 1 depending on if x < y, x == y, or
             * x > y, respectively.
             *
             * @param x - Unsigned integer.
             * @param y - Unsigned integer.
             * @returns Sign of x - y.
             */
            function cmp(x: uli_t, y: uli_t): sign_t;
            /**
             * Shifts the given number of bits within the existing limbs, i.e.,
             * the allocated space is not expanded. Shifting may create an integer
             * with a leading one.
             *
             * <p>
             *
             * ASSUMES: offset >= 0.
             *
             * @param x - Signed integer.
             * @param offset - Number of bit positions to shift.
             */
            function shiftleft(x: uli_t, offset: size_t): void;
            /**
             * Shifts the given number of bits to the right within
             * the allocated space, i.e., the space is not reduced.
             *
             * <p>
             *
             * ASSUMES: offset >= 0.
             *
             * @param x - Array to be shifted.
             * @param offset - Number of bit positions to shift.
             */
            function shiftright(x: uli_t, offset: size_t): void;
            /**
             * Sets w = x + y mod 2^(w.length * 30) with sign extension
             * for x and y by default, without otherwise.
             *
             * <p>
             *
             * References: HAC 14.7.
             *
             * @param w - Variable which may be x or y.
             * @param x - Signed term.
             * @param y - Signed term.
             * param signed - Indicates unsigned addition.
             */
            function add(w: uli_t, x: uli_t, y: uli_t, signed ? : bin_t): void;
            /**
             * Sets w to the negative of x in two's complement
             * representation using L * 30 bits, where L is the number of
             * limbs in w.
             *
             * <p>
             *
             * ASSUMES: w has at least as many limbs as x.
             *
             * @param w - Variable which may be x.
             * @param x - Signed integer.
             */
            function neg(w: uli_t, x: uli_t): void;
            /**
             * Interprets x as an integer in two's complement representation,
             * replaces it by the absolute value in two's complement and returns
             * the sign of x.
             *
             * @param x - Signed integer.
             * @return Sign of x.
             */
            function tosigned(x: uli_t): sign_t;
            /**
             * Sets w = x - y if x >= y and otherwise it simply
             * propagates -1, i.e., 0x3fffffff, through the remaining words of
             * w.
             *
             * <p>
             *
             * ASSUMES: for normal use x >= y, and x and y have B and B' bits and
             * w can store B bits. A natural choice is to use L >= L' limbs for x
             * and y respectively and L limbs for w, but the number of limbs can
             * be arbitrary.
             *
             * <p>
             *
             * References: HAC 14.9.
             *
             * @param w - Variable.
             * @param x - Unsigned term.
             * @param y - Unsigned term.
             * @returns Finally carry.
             */
            function sub(w: uli_t, x: uli_t, y: uli_t): int32_t;
            /**
             * Specialized implementation of muladd_loop() for 30-bit
             * words. This is essentially a naive double-precision multiplication
             * computation done in a loop which encapsulates the computations
             * needed in multiplication, squaring, and division. This code is
             * quite sensitive to replacing the constants with variables, which
             * explains why it is generated from source with macros. Using two's
             * complement for temporary values this can be used as a "mulsub_loop"
             * as well.
             *
             * <p>
             *
             * Computes (pseudo-code) that due to limited precision and 31-bit
             * unsigned int limitation does not work in JavaScript:
             *
             * <pre>
             * for (var j = start; j < end; j++) {
             *     tmp = x[j] * Y + w[i + j] + c;
             *     w[i + j] = tmp & 0x3fffffff;
             *     c = tmp >>> 30;
             * }
             * return c;
             * </pre>
             *
             * <p>
             *
             * Note that if Y < 2^(30 + b), then the output carry c is
             * only guaranteed to be smaller than 2^(30 + b) for a bit b,
             * which does not necessarily fit into a word.
             *
             * <p>
             *
             * ASSUMES: Y < 2^(30 + b).
             *
             * @param w - Unsigned integer.
             * @param x - Unsigned integer.
             * @param start - Start index into x.
             * @param end - End index into x.
             * @param Y - Scalar.
             * @param i - Index in w.
             * @param c - Input carry.
             * @returns Final carry.
             */
            function muladd_loop(w: uli_t, x: uli_t, start: size_t, end: size_t, Y: word_a1_t, i: size_t, c: word_a1_t): int32_t;
            /**
             * Specialized implementation of mul_mont_loop() for 30-bit
             * words. This is essentially two interlaced muladd_loops, i.e., it is
             * an optimization compared to running muladd_loop() twice. This loop
             * writes to len + 2 elements.
             *
             * <p>
             *
             * Computes (pseudo-code) that due to limited precision and 31-bit
             * unsigned int limitation does not work in JavaScript:
             *
             * <pre>
             * u = (a[i] * w + xi * yw) & 0x3fffffff;
             * c = 0;
             * for (var j = 0; j < len; j++) {
             *     tmp = w[i + j] + y[j] * xi + m[j] * u + c;
             *     w[i + j] = tmp & 0x3fffffff;
             *     c = tmp >>> 30;
             * }
             * t = w[i + j] + c;
             * w[i + j] = t & 0x3fffffff;
             * w[i + j + 1] = t >>> 30;
             * </pre>
             *
             * <p>
             *
             * ASSUMES: xi, w, yw < 2^30 and that a has i + len + 2
             * limbs.
             *
             * @param a - Unsigned integer.
             * @param y - Unsigned integer.
             * @param m - Unsigned integer.
             * @param len - Maximal number of elements in y and m.
             * @param xi - Scalar.
             * @param w - Scalar.
             * @param yw - Scalar.
             * @param i - Index into a.
             */
            function mul_mont_loop(a: uli_t, y: uli_t, m: uli_t, len: size_t, xi: word_t, w: word_t, yw: word_t, i: size_t): void;
            /**
             * Sets w = x * x.
             *
             * <p>
             *
             * ASSUMES: x is non-negative with L and L' limbs respectively, and
             * that w has at least L + L' limbs.
             *
             * <p>
             *
             * References: HAC 14.16.
             *
             * @param w - Unsigned integer.
             * @param x - Unsigned factor.
             */
            function square_naive(w: uli_t, x: uli_t): void;
            /**
             * Sets w = x * x. The depth parameter determines the
             * recursive depth of function calls and must be less than 3.
             *
             * <p>
             *
             * ASSUMES: x is non-negative and has L limbs and w has at least 2 * L
             * limbs.
             *
             * <p>
             *
             * References: HAC <sectionsign>14.2,
             * https://en.wikipedia.org/wiki/Karatsuba_algorithm
             *
             * @param w - Variable.
             * @param x - Unsgined factor.
             * @param depth - Recursion depth of the Karatsuba algorithm.
             */
            const square_karatsuba: (w: uli_t, x: uli_t, depth: size_t, len ? : size_t) => void;
            /**
             * Sets w = x * x.
             *
             * <p>
             *
             * ASSUMES: x is non-negative with L and L' limbs respectively, and
             * that w has at least L + L' limbs.
             *
             * <p>
             *
             * References: HAC 14.16.
             *
             * @param w - Variable.
             * @param x - Unsigned factor.
             * @param len - Actual lengths of inputs. Useful when stored in longer arrays.
             */
            function square(w: uli_t, x: uli_t, len ? : size_t): void;
            /**
             * Sets w = x * y.
             *
             * <p>
             *
             * ASSUMES: x and y are both non-negative with W and W' limbs
             * respectively, and that w has at least W + W' limbs.
             *
             * <p>
             *
             * References: HAC 14.12.
             *
             * @param w - Variable.
             * @param x - Unsigned factor.
             * @param y - Unsigned factor.
             */
            function mul_naive(w: uli_t, x: uli_t, y: uli_t): void;
            /**
             * Sets w = x * y. The depth parameter determines the
             * recursive depth of function calls and must be less than 3.
             *
             * <p>
             *
             * ASSUMES: x and y are both non-negative, with W and W' limbs
             * respectively, and that w has at least W + W' limbs.
             *
             * <p>
             *
             * References: HAC <sectionsign>14.2,
             * https://en.wikipedia.org/wiki/Karatsuba_algorithm
             *
             * @param w - Variable.
             * @param x - Unsigned factor.
             * @param y - Unsigned factor.
             * @param depth - Recursion depth of the Karatsuba algorithm.
             * @param len - Actual lengths of inputs. Useful when stored in longer arrays.
             */
            const mul_karatsuba: (w: uli_t, x: uli_t, y: uli_t, depth: size_t, len ? : size_t) => void;
            /**
             * Sets w = x * y.
             *
             * <p>
             *
             * ASSUMES: x and y are both non-negative with W and W' limbs
             * respectively, and that w has at least W + W' limbs.
             *
             * @param w - Variable.
             * @param x - Unsigned factor.
             * @param y - Unsigned factor.
             * @param len - Actual lengths of inputs. Useful when stored in longer arrays.
             */
            function mul(w: uli_t, x: uli_t, y: uli_t, len ? : size_t): void;
            /**
             * Computes the 2-by-1 reciprocal of a word d.
             *
             * <p>
             *
             * ASSUMES: most significant bit of d is set, i.e., we have
             * 2^30/2 <= d < 2^30.
             *
             * <p>
             *
             * References: Functionally equivalent to RECIPROCAL_WORD in MG.
             *
             * @param d - Normalized divisor.
             * @returns 2-by-1 reciprocal of d.
             */
            const reciprocal_word: (d: word_t) => word_t;
            /**
             * Computes the 3-by-2 reciprocal of d, where d has two
             * limbs/words.
             *
             * <p>
             *
             * ASSUMES: most significant bit of d is set, i.e., we have
             * 2^(2 * 30)/2 <= d < 2^(2*30).
             *
             * <p>
             *
             * References: Algorithm RECIPROCAL_WORD_3BY2 in MG.
             *
             * @param d - Normalized divisor.
             * @returns 3-by-2 reciprocal of d.
             */
            const reciprocal_word_3by2: (d: uli_t) => word_t;
            /**
             * Computes q and r such that u = q * d + r, where d has two
             * limbs/words, u has three limbs and three words, and 0 <= r < d.
             *
             * <p>
             *
             * ASSUMES: most significant bit of d is set, i.e., we have
             * 2^(2 * 30)/2 <= d < 2^(2*30).
             *
             * <p>
             *
             * References: Algorithm DIV3BY2 in MG.
             *
             * @param r - Two-word integer that ends up holding the remainder.
             * @param u - Three-word dividend.
             * @param d - Normalized divisor.
             * @param neg_d - Negative of d in two's complement.
             * @param v - 3by2 reciprocal of d.
             * @returns Integer quotient q = u / d.
             */
            const div3by2: (r: uli_t, u: uli_t, d: uli_t, neg_d: uli_t, v: word_t) => word_t;
            /**
             * Sets q and r such that x = qy + r, except that r is
             * computed in place of x, so at the end of the execution x is
             * identified with r. WARNING! y is cached in its normalized form
             * along with its negation and reciprocal. This is pointer based,
             * i.e., it is assumed that the contents of y do not change. High
             * level routines must accomodate.
             *
             * <p>
             *
             * ASSUMES: x and y are positive, x has W words and at least W + 2
             * limbs (i.e., two leading unused zero words), y has L' words, and w
             * has at least L'' = max{W - L', 0} + 1 limbs and will finally hold
             * a result with at most L'' words and a leading zero limb.
             *
             * <p>
             *
             * References: HAC 14.20.
             *
             * @param q - Variable holding unsigned quotient at end of computation.
             * @param x - Unsigned divident and holder of remainder at end of computation.
             * @param y - Unsigned divisor.
             */
            const div_qr: (w: uli_t, x: uli_t, y: uli_t) => void;
            /**
             * Sets w to a random integer modulo m > 0 with distribution
             * statistically close to uniform.
             *
             * @param w - Variable.
             * @param m - Modulus.
             * @param rs - Source of randomness.
             * @param sd - Determines statistical distance.
             */
            const modrandom: (w: uli_t, m: uli_t, rs: RandomSource, sd ? : size_t) => void;
            /**
             * Sets w = x * y mod m.
             *
             * <p>
             *
             * ASSUMES: m > 1, 0 <= x,y < m and w has Wx + Wy + 2 limbs, where Wx
             * and Wy are the number of words in x and y respectively.
             *
             * @param w - Array holding the result.
             * @param x - Integer in 0 <= x < m.
             * @param m - Modulus.
             */
            const modmul: (w: uli_t, x: uli_t, y: uli_t, m: uli_t) => void;
            /**
             * Montgomery multiplication, i.e., it sets a = x * y * R^(-1) mod m,
             * where b = 2^30, R = b^n, w is the Montgomery inverse of m,
             * and n is the number of words in m, i.e., m < 2^n.
             *
             * <p>
             *
             * ASSUMES: m > 0 is odd, 0 <= x,y < m, m has L limbs of which at
             * least the top two words equal zero, a is distinct from x,
             * y. Furthermore, m, x, and y must have L limbs and a 2 * L + 2
             * limbs.
             *
             * <p>
             *
             * References: HAC 14.36.
             */
            function mul_mont(a: uli_t, x: uli_t, y: uli_t, m: uli_t, mn: size_t, w: word_t): void;
            /**
             * Abstract class which represents a way to square and multiply
             * elements in a modular ring for use in exponentiation algorithms.
             */
            abstract class ModPowCtx {
                m: uli_t;
                mn: size_t;
                lim1: size_t;
                lim2: size_t;
                /**
                 * Creates a context from a modulus. A product of two integers
                 * with lim1 limbs can have at most 2 * lim1 limbs, but for
                 * modular reduction we need two extra limbs.
                 *
                 * @param m Modulus.
                 */
                constructor(m: uli_t);
                /**
                 * Returns the appropriate size of a pre-computed table for
                 * windowing exponentiation.
                 *
                 * @param bitLength Number of bits in exponent.
                 */
                abstract getk(bitLength: size_t): size_t;
                /**
                 * Transforms an element to a form which this context can perform
                 * multiplications with.
                 *
                 * @param xt Transformed element.
                 * @param x Element.
                 */
                abstract set(xt: uli_t, x: uli_t): void;
                /**
                 * Recovers an element from a transformed element.
                 *
                 * @param x Element.
                 * @param xt Transformed element.
                 */
                abstract get(x: uli_t, xt: uli_t): void;
                /**
                 * Sets xt to the transformation of one.
                 *
                 * @param xt Transformed one.
                 */
                abstract setOne(xt: uli_t): void;
                /**
                 * Computes the transformed square of a transformed element.
                 *
                 * @param wt Transformed square.
                 * @param xt Transformed element.
                 */
                abstract square(wt: uli_t, xt: uli_t): void;
                /**
                 * Computes the transformed product of a transformed elements.
                 *
                 * @param wt Transformed square.
                 * @param xt Transformed element.
                 * @param yt Transformed element.
                 */
                abstract mul(wt: uli_t, xt: uli_t, yt: uli_t): void;
            }
            /**
             * Class which represents the straightforward way to square and
             * multiply in a modular ring for use in exponentiation algorithms.
             */
            class ModularCtx extends ModPowCtx {
                getk(bitLength: size_t): size_t;
                set(xt: uli_t, x: uli_t): void;
                get(x: uli_t, xt: uli_t): void;
                setOne(xt: uli_t): void;
                square(wt: uli_t, xt: uli_t): void;
                mul(wt: uli_t, xt: uli_t, yt: uli_t): void;
                static getCtx(m: uli_t): ModPowCtx;
            }
            /**
             * Sets w = b^e mod m.
             *
             * <p>
             *
             * ASSUMES: 0 < b < m, and 0 < e, and w, b and m have L limbs.
             *
             * <p>
             *
             * References: HAC 14.82, 14.94.
             *
             * @param w - Array holding the result.
             * @param b - Basis integer.
             * @param e - Exponent.
             * @param m - Modulus.
             */
            const modpow_sqrmul: (w: uli_t, b: uli_t, e: uli_t, m: uli_t, getCtx: (m: uli_t) => ModPowCtx) => void;
            /**
             * Sets w = b^e mod m.
             *
             * <p>
             *
             * ASSUMES: 0 < b < m, and 0 < e, and w, b and m have L limbs.
             *
             * <p>
             *
             * References: HAC 14.85.
             *
             * @param w - Array holding the result.
             * @param b - Basis integer.
             * @param e - Exponent.
             * @param m - Modulus.
             */
            const modpow_window: (w: uli_t, b: uli_t, e: uli_t, m: uli_t, getCtx: (m: uli_t) => ModPowCtx) => void;
            /**
             * Returns a table of all possible modular products of a
             * list of bases. More precisely, given a list b of k bases and a
             * modulus m, it returns t, where t is the table computed as t[x]
             * = b[0]^x[0] * ... * b[k-1]^x[k-1] mod m, where x[i] is the ith bit
             * of the integer x.
             *
             * <p>
             *
             * We allow this method to allocate memory, since it is expected to be
             * used rarely relative the amount of computation performed and since
             * more than one table may be used simultaneously.
             *
             * <p>
             *
             * ASSUMES: m has L limbs and b[i] has L limbs and all inputs are
             * positive.
             *
             * <p>
             *
             * References: HAC 14.88
             *
             * @param b - List of bases.
             * @param m - Modulus.
             * @returns t Table for products.
             */
            const modpowprodtab_inner: (b: uli_t[], m: uli_t) => uli_t[];
            /**
             * Applies {@link modpowprodtab} to subsequences of a given width of
             * the input and returns the resulting tables as an array.
             *
             * <p>
             *
             * We allow this method to allocate memory, since it is expected to be
             * used rarely relative the amount of computation performed and since
             * more than one table may be used simultaneously.
             *
             * <p>
             *
             * ASSUMES: m has L limbs and b[i] has L limbs and all inputs are
             * positive, and width <= 30.
             *
             * <p>
             *
             * References: HAC 14.88
             *
             * @param b - List of bases.
             * @param m - Modulus.
             * @param width - Maximal number of bases used for each table.
             * @returns t Array of tables for products.
             */
            function modpowprodtab(b: uli_t[], m: uli_t, width: size_t): uli_t[][];
            /**
             * Computes a simultaneous exponentiation using tables of pre-computed
             * tables t for at most width bases each, but based on exactly k
             * bases, and modulus m, i.e., it sets w = b[0]^e[0] * ... *
             * b[k-1]^e[k-1], where e has length k.
             *
             * <p>
             *
             * ASSUMES: m > 1 has L limbs and each e[i] has L limbs and all inputs
             * are positive, and that the table was computed with the same number
             * of bases and the same modulus m.
             *
             * <p>
             *
             * References: HAC 14.88
             *
             * @param w - Holds the result.
             * @param t - Tables of products.
             * @param e - List of exponents.
             * @param m - Modulus
             * @param width - Width of each block that is precomputed separately.
             */
            const modpowprod: (w: uli_t, t: uli_t[][], e: uli_t[], m: uli_t, width: size_t) => void;
            /**
             * Returns the bits between the start index and end index
             * as an integer.
             *
             * <p>
             *
             * ASSUMES: s <= most significant bit of x and s < e
             *
             * @param x - Integer to slice.
             * @param s - Inclusive start index.
             * @param e - Exclusive end index.
             * @returns Bits between the start index and end index as an integer.
             */
            function slice(x: uli_t, s: size_t, e: size_t): uli_t;
            /**
             * Returns a minimal hexadecimal representation in two's complement.
             *
             * @param x - Unsigned integer.
             * @returns Hexadecimal string representation of the array.
             */
            function hex(x: uli_t): string;
            /**
             * Returns the integer represented by the input.
             *
             * @param s - Hexadecimal representation of an integer.
             * @returns Represented integer.
             */
            function hex_to_li(s: string): uli_t;
            /**
             * Miller-Rabin test for the input integer using the given number of
             * repetition. We do not bother optimizing for small integers with
             * trial division.
             *
             * <p>
             *
             * ASSUMES: n >= 0 and t > 0
             *
             * <p>
             *
             * References: HAC 4.24
             *
             * @param n - Non-negative integer to test.
             * @param t - Repetitions.
             * @param rs - Source of randomness.
             * @returns True or false depending on if n is considered to be a prime or not.
             */
            const miller_rabin: (n: uli_t, t: size_t, rs: RandomSource) => boolean;
        }
        namespace li {
            import VerificatumObject = verificatum.base.VerificatumObject;
            /**
             * Container class for signed mutable integers with manual memory
             * management as for uli_t. Instantiated with sign and value, with a
             * length of the underlying array for an uninitialized instance, or
             * with no parameters.
             */
            class SLI extends VerificatumObject {
                sign: sign_t;
                value: uli_t;
                length: size_t;
                /**
                 * Constructs an SLI.
                 *
                 * @param first - Empty, sign, or number of words in empty instance.
                 * @param second - Empty or array containing value.
                 * @throws Error if an input is incorrectly formatted, but does
                 * not perform a full dynamic type check of the input.
                 */
                constructor(first ? : sign_t | size_t, second ? : uli_t);
            }
            /**
             * Thin layer on top of the uli module that provides mutable signed
             * integers with basic modular arithmetic along with a few low level
             * routines that requires signed integers to implement.
             *
             * <p>
             *
             * It also uses a minimal container class SLI that represents a
             * signed integer. All operations on are executed on pre-existing SLI
             * instances, so it is the responsibility of the programmer to ensure
             * that data fits inside the allocated space.
             *
             * <p>
             *
             * This approach is motivated by the need to preserve efficiency and
             * still encapsulate as much implementation details as possible.
             *
             * <p>
             *
             * <a href="http://cacr.uwaterloo.ca/hac">Handbook of Cryptography
             * (HAC), Alfred J. Menezes, Paul C. van Oorschot and Scott
             * A. Vanstone</a> gives a straightforward introduction to the basic
             * algorithms used and we try to follow their notation for easy
             * reference.
             *
             * <p>
             *
             * <table style="text-align: left;">
             * <tr><th>Reference        </th><th> Operation</th><th> Comment</th></tr>
             * <tr><td>HAC 2.149</td><td> Jacobi symbol</td><td></td></tr>
             * <tr><td>HAC 14.36</td><td> Montgomery modular multiplication</td><td></td></tr>
             * <tr><td>HAC 14.61</td><td> Extended Euclidian algorithm (variation)</td><td></td></tr>
             * <tr><td>HAC 14.94</td><td> Montgomery modular exponentiation</td><td></td></tr>
             * </table>
             * TSDOC_MODULE
             */
            /**
             * Truncates the input to the shortest possible array that represents
             * the same absolute value in two's complement. It sets the sign to
             * zero if necessary, but does not modify the sign otherwise.
             *
             * @param x - Signed integer.
             */
            function normalize(x: SLI): void;
            /**
             * Resizes the underlying array to the given length.
             *
             * @param a - SLI to be resized.
             * @param len - New length of SLI.
             */
            function resize(a: SLI, len: size_t): void;
            /**
             * Returns the sign of a number.
             *
             * @param n - A Javascript "number".
             * @returns Sign of number as -1, 0, or 1.
             */
            function sign(n: int52_t): sign_t;
            /**
             * Sets a = b, where b is an SLI instance.
             *
             * <p>
             *
             * ASSUMES: b has L words and a has at least L limbs.
             *
             * @param a - SLI holding the result.
             * @param b - Integer value represented as a SLI.
             */
            function set(a: SLI, b: SLI): void;
            /**
             * Sets a = b, where b is a "number".
             *
             * <p>
             *
             * ASSUMES: 0 <= |b| < 2^WORDSIZE.
             *
             * @param a - SLI holding the result.
             * @param b - Integer value represented as a "number".
             */
            function set(a: SLI, b: word_t): void;
            /**
             * Returns a copy of a, where the length of the underlying array is
             * len if this increases its length.
             *
             * @param a - Original array.
             * @param len - Length of resulting SLI if it is larger than the
             * length of the original SLI.
             * @returns Copy of original SLI.
             */
            function copy(a: SLI, len: size_t): SLI;
            /**
             * Returns a copy of a.
             *
             * @param a - Original array.
             * @returns Copy of original SLI.
             */
            function copy(a: SLI): SLI;
            /**
             * Returns -1, 0, or 1 depending on if a < b, a == b, or
             * a > b.
             *
             * @param a - Left SLI.
             * @param b - Right SLI.
             * @returns Value of comparison predicate on a and b.
             */
            function cmp(a: SLI, b: SLI): sign_t;
            /**
             * Returns true or false depending on if a = b or not.
             *
             * @param a - Left SLI.
             * @param b - Right SLI.
             * @returns True or false depending on if the SLIs represent the same
             * integer or not.
             */
            function equals(a: SLI, b: SLI): boolean;
            /**
             * Returns true or false depending on a = 0 or not.
             *
             * @param a - Integer represented as a SLI.
             * @returns True or false depending on if a is zero or not.
             */
            function iszero(a: SLI): boolean;
            /**
             * Returns true or false depending on a = 1 or not.
             *
             * @param a - Integer represented as a SLI.
             * @returns True or false depending on if a is zero or not.
             */
            function isone(a: SLI): boolean;
            /**
             * Shifts the given number of bits within the SLI,
             * i.e., the allocated space is not expanded.
             *
             * <p>
             *
             * ASSUMES: offset >= 0.
             *
             * @param x - SLI to be shifted.
             * @param offset - Number of bit positions to shift.
             */
            function shiftleft(a: SLI, offset: size_t): void;
            /**
             * Shifts the given number of bits to the right within
             * the allocated space, i.e., the space is not reduced.
             *
             * <p>
             *
             * ASSUMES: offset >= 0.
             *
             * @param x - SLI to be shifted.
             * @param offset - Number of bit positions to shift.
             */
            function shiftright(a: SLI, offset: size_t): void;
            /**
             * Sets a = b + c.
             *
             * <p>
             *
             * ASSUMES: b and c have B and B' bits and a can store B + B' + 1
             * bits, or B + B' bits depending on if the signs of b and c are equal
             * or not.
             *
             * @param a - SLI holding the result.
             * @param b - Left term.
             * @param c - Right term.
             */
            function add(a: SLI, b: SLI, c: SLI): void;
            /**
             * Sets a = b - c.
             *
             * <p>
             *
             * ASSUMES: b and c have B and B' bits and a can store B + B' + 1
             * bits, or B + B' bits depending on if the signs of b and c are
             * distinct or not.
             *
             * @param a - SLI holding the result.
             * @param b - Left term.
             * @param c - Right term.
             */
            function sub(a: SLI, b: SLI, c: SLI): void;
            /**
             * Sets a = b * c.
             *
             * <p>
             *
             * ASSUMES: b and c have L and L' limbs and a has at least L + L' limbs.
             *
             * @param a - SLI holding the result.
             * @param b - Left factor.
             * @param c - Right factor.
             */
            const mul: (a: SLI, b: SLI, c: SLI, len ? : size_t) => void;
            /**
             * Sets a = b * c, where c is a word.
             *
             * <p>
             *
             * ASSUMES: b has L limbs, c is a word such that 0 <=
             * c < 2^WORDSIZE, and a has at least L + 1 limbs.
             *
             * @param a - SLI holding the result.
             * @param b - Left factor.
             * @param c - Right factor.
             */
            const mul_word: (a: SLI, b: SLI, c: word_t) => void;
            /**
             * Sets a = b^2.
             *
             * <p>
             *
             * ASSUMES: b has L words and a has at least 2 * L limbs.
             *
             * @param a - SLI holding the result.
             * @param b - Factor.
             */
            function square(a: SLI, b: SLI): void;
            /**
             * Computes q, r such that q = a / b + r with a / b and r rounded with
             * sign, in particular, if b is positive, then 0 <= r < b. Then it
             * sets a = r. We are faithful to the mathematical definition for
             * signs.
             *
             * <p>
             *
             * ASSUMES: a and b are positive, a has L words and at least L + 2
             * limbs (i.e., two leading unused zero words), b has L' limbs, and q
             * has at least L'' = max{L - L', L', 0} + 1 limbs and will finally
             * hold a result with at most L'' words and a leading zero limb.
             *
             * @param q - SLI holding the quotient.
             * @param a - Dividend.
             * @param b - Divisor.
             */
            function div_qr(q: SLI, a: SLI, b: SLI): void;
            /**
             * Sets a = b mod c (this is merely syntactic sugar for
             * div_qr).
             *
             * @param a - SLI holding the result.
             * @param b - Dividend.
             * @param c - Modulus.
             */
            const mod: (a: SLI, b: SLI, c: SLI) => void;

            function egcd_binary_reduce(u: SLI, A: SLI, B: SLI, x: SLI, y: SLI): void;
            /**
             * Sets a, b, and v such that a * x + b * y = v and v is
             * the greatest common divisor of x and y.
             *
             * <p>
             *
             * ASSUMES: x, y >= 0
             *
             * References: HAC 14.61 (5th printing + errata)
             *
             * @param a - Linear coefficient of Bezout expression.
             * @param b - Linear coefficient of Bezout expression.
             * @param v - Greatest common divisor of x and y.
             * @param x - Left integer.
             * @param y - Right integer.
             */
            const egcd: (a: SLI, b: SLI, v: SLI, x: SLI, y: SLI) => void;
            /**
             * Sets a such that w * x = 1 mod p.
             *
             * <p>
             *
             * ASSUMES: p > 0 is on odd prime.
             *
             * <p>
             *
             * References: HAC 14.61.
             *
             * @param w - SLI holding the result.
             * @param x - Integer to invert.
             * @param p - Positive odd prime modulus.
             */
            const modinv: (w: SLI, x: SLI, p: SLI) => void;
            /**
             * Sets w = b^e mod m.
             *
             * <p>
             *
             * ASSUMES: 0 < b < m, e > 0, and m > 1, m has L limbs, w has at least
             * L limbs, and b and e have arbitrary number of limbs.
             *
             * @param w - SLI holding the result.
             * @param b - Basis integer.
             * @param e - Exponent.
             * @param m - Modulus.
             */
            function modpow(w: SLI, b: SLI, e: SLI, m: SLI): void;
            /**
             * Returns (a | b), i.e., the Jacobi symbol of a modulo b for an odd
             * integer b > 2. (This is essentially a GCD algorithm that keeps track
             * of the residue symbol.)
             *
             * <p>
             *
             * References: HAC 2.149.
             *
             * @param a - Integer modulo b.
             * @param b - An odd prime modulus.
             * @returns Jacobi symbol of this instance modulo the input.
             */
            function jacobi(a: SLI, b: SLI): sign_t;
            /**
             * Sets w to an integer such that w^2 = x mod p, i.e., it
             * computes the square root of an integer modulo a positive odd prime
             * employing the Tonelli-Shanks algorithm.
             *
             * @param w - Holding the result.
             * @param x - Integer of which the square root is computed.
             * @param p - Positive odd prime modulus.
             */
            const modsqrt: (w: SLI, x: SLI, p: SLI) => void;
            /**
             * Returns a raw (no leading "0x" or similar) hexadecimal
             * representation of the input with sign indicated by a leading "-"
             * character if negative and capital characters.
             *
             * @param a - SLI to represent.
             * @returns Hexadecimal representation of SLI.
             */
            function hex(a: SLI): string;
            /**
             * Returns the Montomery inverse of m modulo 2^WORDSIZE, i.e., the
             * inverse w such that w = -m^(-1) mod 2^WORDSIZE.
             *
             * <p>
             *
             * ASSUMES: m is non-zero and odd.
             *
             * <p>
             *
             * @returns Montgomery inverse of m.
             */
            function neginvm_mont(m: uli_t): word_t;
        }
        import ModPowCtx = verificatum.arithm.uli.ModPowCtx;
        import RandomSource = verificatum.base.RandomSource;
        import SLI = verificatum.arithm.li.SLI;
        enum ModPowAlg {
            smart = 0,
                modular = 32,
                montgomery = 48,
                sqrmul = 2,
                window = 3,
                modular_sqrmul = 34,
                montgomery_sqrmul = 50,
                modular_window = 35,
                montgomery_window = 51
        }
        /**
         * Class which represents Montgomery's way to square and
         * multiply in a modular ring for use in exponentiation algorithms.
         */
        class MontgomeryCtx extends ModPowCtx {
            q: uli_t;
            r: uli_t;
            rr: uli_t;
            mw: word_t;
            Rmodm: uli_t;
            R2modm: uli_t;
            one: uli_t;
            /**
             * Creates a Montgomery context from a modulus.
             *
             * @param m Modulus.
             */
            constructor(m: uli_t);
            getk(bitLength: size_t): size_t;
            set(xt: uli_t, x: uli_t): void;
            get(x: uli_t, xt: uli_t): void;
            setOne(xt: uli_t): void;
            square(wt: uli_t, xt: uli_t): void;
            mul(wt: uli_t, xt: uli_t, yt: uli_t): void;
            static getCtx(m: uli_t): MontgomeryCtx;
        }
        /**
         * Converts various representations of integers to and from instances
         * of LI with rigorous dynamic type checking and static typing as far
         * as is possible. This implementation is meant to be stringent, but
         * not necessarily fast. It does not treat powers of two as a special
         * case.
         */
        class LIE {
            /**
             * Maximal radix.
             */
            static readonly MAX_RADIX = 64;
            /**
             * Maximal radix for strings of digits in standard alphabets.
             */
            static readonly MAX_STRING_RADIX = 36;
            /**
             * Returns the number of bytes needed to generate the
             * given number of bits.
             *
             * @param bitLength - Number of bits.
             * @returns Number of bytes needed.
             */
            static byteLengthRandom(bitLength: size_t): size_t;
            /**
             * Verifies that a radix is an integer in the range [2, maxRadix],
             * where maxRadix defaults to LIE.MAX_RADIX.
             *
             * @param maxRadix - Maximal radix allowed. This defaults to LIE.MAX_RADIX.
             * @returns The input radix.
             * @throws Error if the radix is not an integer in [2, maxRadix].
             */
            private static typeCheckRadix;
            /**
             * Verifies that a sign is an integer in {-1, 0, 1}.
             *
             * @returns The input sign.
             * @throws Error if the sign is not in {-1, 0, 1}.
             */
            private static typeCheckSign;
            /**
             * Verifies that the input is an array of integers in [0, bound]
             * of positive length, where inclusive bound is at most 2^30 - 1.
             *
             * @param value - Array to be checked.
             * @param bound - Inclusive upper bound on the elements of the array
             * @returns The input array.
             * @throws Error if the array does not represent a normalized
             * non-negative integer in the given basis.
             */
            private static typeCheckUintArray;
            /**
             * Verify that (sign, value) is a valid representation of a
             * sign-value represented integer, where the value is a
             * non-negative integer in minimal two's complement
             * representation, i.e., it has at most WORDSIZE leading zero
             * bits.
             *
             * @param sign - Supposedly a sign.
             * @param value - Supposedly a non-negative integer in two's complement.
             */
            static fromSignValue(sign: int32_t, value: any[], radix: radix_t): [
                sign_t,
                uint30_t[]
            ];
            /**
             * Converts an unsigned integer represented in the given radix in
             * small endian order to an instance of LI.
             *
             * @param values - Representation in small endian order.
             * @param rx - Integer radix in [2,LIE.MAX_RADIX].
             * @returns Instance of LI representing the input integer.
             */
            private static fromRx;
            /**
             * Converts a non-negative integer to the given radix in small
             * endian order.
             *
             * @param li - Non-negative integer to convert.
             * @param rx - Integer radix in [2,LIE.MAX_RADIX].
             * @returns Integer as an array of digits in small endian order in
             * the given radix.
             */
            private static toRx;
            /**
             * Converts a JavaScript number to an instance of LI, the input
             * must be an integer in the set [-(2^53 - 1), 2^53 - 1].
             *
             * @param num Integer of type number.
             * @return Corresponding value as a LI.
             * @throws Error if the number is not an integer.
             */
            static fromNumber(num: number): LI;
            /**
             * Returns the signed number formed by interpreting the least
             * significant 53 bits of the magnitude of the input as the mantissa
             * and setting the sign.
             *
             * @param li Integer to convert.
             */
            static toNumber(li: LI): number;
            /**
             * Converts a sign value representation of an integer in the given
             * radix in small endian order to an instance of LI. Any integer
             * radix in [2,LIE.MAX_RADIX] works.
             *
             * @param rx - Integer radix in [2,LIE.MAX_RADIX].
             * @returns Integer as an array of digits in small endian order in
             * the given radix.
             */
            static fromRadix([sign, value]: [sign_t, int32_t[]], radix: int32_t): LI;
            /**
             * Converts an integer to a sign-magnitude pair in the given radix
             * in small endian order. Any integer radix in [2,LIE.MAX_RADIX] works.
             *
             * @param rx - Integer radix in [2,LIE.MAX_RADIX].
             * @returns Integer as an array of digits in small endian order in
             * the given radix.
             */
            static toRadix(li: LI, radix: int32_t): [sign_t, int32_t[]];
            /**
             * Converts an integer in two's complement byte array
             * representation to a sign value pair. Spurious leading bits are
             * ignored.
             *
             * @param bytes - Two's complement representation of an integer.
             * @returns Sign value pair representation of the input integer.
             * @throws Error if the input is not a normalized representation.
             */
            static fromByteArray(bytes: uint8_t[]): [sign_t, uli_t];
            private static readDigit;
            /**
             * Converts a string in the given radix to a sign value representation
             * in small endian order.
             *
             * @param s - String to convert.
             * @param rx - Integer radix in [2,LIE.MAX_RADIX].
             * @returns Integer as a sign value pair.
             */
            static fromString(s: string, radix: int32_t, maxRadix ? : radix_t): LI;
            /**
             * Returns a sign value representation of a non-negative random
             * integer with the given nominal number of bits.
             *
             * @param bitLength - Positive nominal number of bits.
             * @param randomSource - Source of randomness.
             */
            static fromRandomSource(bitLength: size_t, randomSource: RandomSource): [
                sign_t,
                uli_t
            ];
        }
        /**
         * Class for large immutable signed integers that handles memory
         * allocation and provides utility functions. All constructors perform
         * a complete dynamic type check of the inputs.
         */
        class LI extends SLI {
            /**
             * Creates an instance from a sign and a magnitude without
             * typechecking the inputs.
             *
             * @param sign - Sign.
             * @param value - Magnitude.
             */
            static create(sign: sign_t, value: uli_t): LI;
            /**
             * Creates an instance from a hexadecimal string representation of
             * a byte array in small endian order interpreted as a
             * non-negative integer.
             *
             * @param s - Hexadecimal string.
             */
            static ux(s: string): LI;
            /**
             * Verifies that the input is a non-negative integer.
             *
             * @param num Value.
             * @return Non-negative integer.
             */
            private static typeCheckSize;
            /**
             * Allocates an instance that violates the invariant that every
             * instance has a normalized magnitude. WARNING! Do not use this.
             *
             * @param limbs - Number of limbs.
             */
            private static alloc;
            /**
             * Converts a JavaScript integer, i.e., an integer in the set
             * [-(2^53 - 1), 2^53 - 1] to an instance of LI.
             *
             * @param num Integer of type number.
             * @return Corresponding value as a LI.
             * @throws Error if the input is not an integer.
             */
            static fromNumber(num: int53_t): LI;
            /**
             * Returns a random integer that is prime with probability at
             * least 1 - 2^certainty using Miller-Rabin primality test.
             *
             * @param bitLength - Bit length of generated prime.
             * @param randomSource - Source of randomness.
             * @param certainty - Determines probability of accepting a composite.
             * @returns Random integer that is most likely prime.
             */
            static getProbablePrime(bitLength: size_t, certainty: size_t, randomSource: RandomSource): LI;
            /**
             * Creates a new instance representing zero, i.e., a shallow copy of
             * zero. This is a way to enable unsafe creation of instances in
             * LI.alloc and LI.create.
             */
            constructor();
            /**
             * Converts a string in the given radix to an instance of LI. The
             * alphabet is defined by the JavaScript Number.parseInt() method
             * for radix in [2,36]. Use toRadix() and your own alphabet for
             * converting strings with larger radix. Negative integers start
             * with a minus character. Leading zeros are ignored.
             *
             * @param s - String to convert.
             * @param rx - Integer radix in [2,36].
             * @returns Integer as a sign value pair.
             */
            constructor(s: string, radix ? : int32_t);
            /**
             * Creates an integer from a sign and array of words. A zero array
             * of {@link WORDSIZE}-bit words throws an error if the sign is
             * incorrect relative the words.
             *
             * @param sign - Sign of the integer.
             * @param value - Array of words representing a non-negative
             * integer in small endian order.
             */
            constructor(sign: sign_t, value: uli_t);
            /**
             * Creates a non-negative integer from a raw array of bytes.
             *
             * @param rawbytes - Array of words representing an non-negative
             * integer.
             */
            constructor(bytes: uint8_t[]);
            /**
             * Samples a random non-negative integer of the given nominal bit
             * length, i.e., additional leading bits may be zero by chance.
             *
             * @param bitLength - Number of randomly chosen bits in the
             * sampled integer.
             * @param randomSource - Source of randomness.
             */
            constructor(bitLength: size_t, randomSource: RandomSource);
            /**
             * Chooses a suitable modular power algorithm narrowed down by the
             * input.
             *
             * @param modulus - Modulus.
             * @param alg - Requested algorithm.
             * @throws Error if the requested algorithm is not feasible for
             * the given modulus.
             */
            private static chooseModPowAlg;
            /**
             * Chooses a suitable modular power algorithm narrowed down by the
             * input.
             *
             * @param modulus - Modulus.
             * @param alg - Requested algorithm.
             * @throws Error if the requested algorithm is not feasible for
             * the given modulus.
             */
            private static getModPowCtxFactory;
            /**
             * Returns this integer as a raw array of words in two's
             * complement and caches it.
             *
             * @return Two's complement representation of this integer.
             */
            private twos;
            /**
             * Returns true or false depending on if this integer is likely
             * to be a prime or not, determined using Miller-Rabins primality
             * test with the given number of repetitions.
             *
             * @param certainty - Repetitions of Miller-Rabins test.
             * @param randomSource - Source of randomness.
             * @returns True or false depending on if this integer is likely to
             * be a prime or not.
             */
            isProbablePrime(certainty: size_t, randomSource: RandomSource): boolean;
            /**
             * Returns a float64_t by interpreting the least significant 53
             * bits of this integer as the mantissa.
             *
             * @returns The 32 least significant bits of this integer in two's
             */
            numberValue(): float64_t;
            /**
             * Returns true or false depending on if this integer is zero or
             * not.
             *
             * @returns True or false depending on if this integer is zero or
             * not.
             */
            isZero(): boolean;
            /**
             * Compares this integer with the input.
             *
             * @param other - Other integer.
             * @returns -1, 0, or 1 depending on if this integer is smaller than,
             * equal to, or greater than the input.
             */
            cmp(other: LI): sign_t;
            /**
             * Checks if this integer is equal to the input.
             *
             * @param other - Other integer.
             * @returns true if and only if this integer equals the input.
             */
            equals(other: LI): boolean;
            /**
             * Bit length of this integer.
             *
             * @returns Bit length of this integer.
             */
            bitLength(): size_t;
            /**
             * Returns the number of bits in the two's complement
             * representation of this integer that differs from the sign
             * bit. This is the Hamming weight for non-negative numbers.
             *
             * @returns Number of bits in the two's complement
             * representation of this integer that differs from the sign
             * bit.
             */
            bitCount(): size_t;
            /**
             * Returns the index of the least significant set bit or -1 if
             * this integer is zero.
             *
             * @returns Index of the least significant set bit or -1 if
             * this integer is zero
             */
            getLSB(): size_t;
            /**
             * Returns 1 or 0 depending on if the given bit is set or not in
             * the two's complement representation of this integer.
             *
             * @param index - Position of bit.
             * @returns 1 or 0 depending on if the given bit is set or not.
             */
            getBit(index: size_t): bin_t;
            /**
             * Set the bit at the given index to a bit value of this integer
             * in two's complement representation.
             *
             * @parameter index - Index.
             * @parameter bit - Bit.
             */
            setBit(index: size_t, bit: bin_t): LI;
            /**
             * Flips the bit at the given index.
             *
             * @parameter index - Index.
             */
            flipBit(index: size_t): LI;
            /**
             * Applies a commutative function f to words at each index of this
             * integer and the input integer. The output of f is computed
             * modulo 2^WORDSIZE.
             *
             * @param other - A second integer.
             * @return Resulting integer.
             */
            private word2;
            /**
             * Applies the function f to words at each index of this
             * integer. The output of f is computed modulo 2^WORDSIZE.
             *
             * @return Resulting integer.
             */
            private word1;
            /**
             * Returns the bitwise AND of this integer and the input.
             *
             * @param other - Other integer.
             * @returns Bitwise AND of this integer and the input.
             */
            and(other: LI): LI;
            /**
             * Returns the bitwise OR of this integer and the input.
             *
             * @param other - Other integer.
             * @returns Bitwise OR of this integer and the input.
             */
            or(other: LI): LI;
            /**
             * Returns the bitwise XOR of this integer and the input.
             *
             * @param other - Other integer.
             * @returns Bitwise XOR of this integer and the input.
             */
            xor(other: LI): LI;
            /**
             * Returns the bitwise complement of this integer.
             *
             * @param other - Other integer.
             * @returns Bitwise complement of this integer.
             */
            not(): LI;
            /**
             * Shifts this integer to the left.
             *
             * @param offset - Bit positions to shift.
             * @returns This integer shifted the given number of bits to the left.
             * @throws ArithmeticException - if the shift distance is
             * Integer.MIN_VALUE.
             */
            shiftLeft(offset: size_t): LI;
            /**
             * Shifts this integer to the right with sign extension, i.e., an
             * arithmetic right shift.
             *
             * @param offset - Bit positions to shift.
             * @returns This integer shifted the given number of bits to the right.
             * Integer.MIN_VALUE.
             */
            shiftRight(offset: size_t): LI;
            /**
             * Shifts this integer to the left for positive offsets and to the
             * right for negative offsets.
             *
             * @param offset - Bit positions to shift.
             * @returns This integer shifted the given number of bits to the left
             * or right depending on the sign of the offset.
             */
            shift(offset: int32_t): LI;
            /**
             * Returns the absolute value of this integer.
             * @returns Absolute value of this integer.
             */
            abs(): LI;
            /**
             * Returns negative of this integer.
             * @returns -this.
             */
            neg(): LI;
            /**
             * Computes sum of this integer and the input.
             *
             * @param term - Other integer.
             * @returns this + term.
             */
            add(term: LI): LI;
            /**
             * Computes difference of this integer and the input.
             *
             * @param term - Other integer.
             * @returns this - term.
             */
            sub(term: LI): LI;
            /**
             * Computes product of this integer and the input.
             *
             * @param factor - Other integer.
             * @returns this * term.
             */
            mul(factor: LI): LI;
            /**
             * Computes square of this integer.
             * @returns this * this.
             */
            square(): LI;
            /**
             * Returns [q, r] such that q = this / divisor + r with
             * 0 <= |r| < divisor. Note that r may be negative, i.e., we round
             * division towards -infinity.
             *
             * @param divisor - Divisor.
             * @returns Quotient and divisor.
             */
            divQR(divisor: LI): [LI, LI];
            /**
             * Computes the integer quotient of this integer and the input.
             *
             * @param divisor - Integer divisor.
             * @returns this / divisor with rounding according to signs.
             */
            div(divisor: LI): LI;
            /**
             * Computes the integer remainder of this integer and the input. Note
             * that the remainder may be negative if this and divisor have
             * different signs.
             *
             * @param divisor - Integer divisor.
             * @returns this % divisor with rounding according to signs.
             */
            remainder(divisor: LI): LI;
            /**
             * Computes integer remainder of this integer divided by
             * the input as a value in [0, modulus - 1].
             *
             * @param modulus - Divisor.
             * @returns Integer remainder.
             */
            mod(modulus: LI): LI;
            /**
             * Syntactic sugar for this.add(term).mod(modulus).
             *
             * @param term - Other integer.
             * @param modulus - Modulus.
             * @returns (this + term) mod modulus.
             */
            modAdd(term: LI, modulus: LI): LI;
            /**
             * Syntactic sugar for this.sub(term).mod(modulus).
             *
             * @param term - Other integer.
             * @param modulus - Modulus.
             * @returns (this - term) mod modulus.
             */
            modSub(term: LI, modulus: LI): LI;
            /**
             * Syntactic sugar for this.mul(factor).mod(modulus).
             *
             * @param term - Other integer.
             * @param modulus - Modulus.
             * @returns (this * term) mod modulus.
             */
            modMul(factor: LI, modulus: LI): LI;
            /**
             * Computes modular power of this integer raised to the exponent
             * modulo the given modulus. This integer must be non-negative.
             *
             * @param exponent - Non-negative exponent.
             * @param modulus - Integer greater than one.
             * @param alg - Algorithm used.
             * @returns this^exponent mod modulus for positive integers.
             * @throws Error if Montgomery exponentiation is used with even
             * modulus, or if the exponent is negative and this integer is not
             * relatively prime to the modulus.
             */
            modPow(exponent: LI, modulus: LI, alg ? : ModPowAlg): LI;
            /**
             * Computes extended greatest common divisor tuple [a, b, v] such
             * that a * this + b * other = v with v >= 0. If this = 0, then it
             * is guaranteed that a = 0, and correspondingly for other and b
             * to guarantee a unique minimal solution.
             *
             * @param other - Other integer.
             * @returns Typle [a, b, v] such that a * this + b * other = v.
             */
            egcd(other: LI): [LI, LI, LI];
            /**
             * Computes modular inverse of this integer modulo the input
             * modulus, which must be relative prime to this integer.
             *
             * @param modulus - Modulus.
             * @returns Integer 0 < x < modulus such that x * this = 1 mod modulus.
             * @throws Error if this integer is not relative prime with the
             * modulus.
             */
            modInv(modulus: LI): LI;
            /**
             * Returns (this | modulus), i.e., the Jacobi symbol of this
             * modulo modulus for an odd modulus > 2.
             *
             * @param modulus - An odd modulus > 2.
             * @returns Jacobi symbol of this instance modulo the input.
             */
            jacobi(modulus: LI): sign_t;
            /**
             * Returns a square root of this integer modulo an odd
             * prime, where this integer is a quadratic residue modulo the prime.
             *
             * @param prime - An odd prime modulus.
             * @returns Square root of this integer modulo the input odd prime.
             */
            modSqrt(prime: LI): LI;
            /**
             * Returns the bits between the start index and end index of the
             * absolute value of this intger as an integer.
             *
             * @param start - Inclusive start index.
             * @param end - Exclusive end index.
             * @returns Bits between the start index and end index of the
             * absolute integer of this integer as an integer.
             */
            slice(start: size_t, end: size_t): LI;
            /**
             * Returns this integer as a byte array in small endian two's
             * complement representation with sign extension if a larger
             * length is requested.
             *
             * @param len - Length of output, if larger than the needed number
             * of bytes it is sign extended, and if smaller it is truncated.
             * @returns Resulting array.
             */
            toByteArray(len ? : size_t): uint8_t[];
            /**
             * Computes a hexadecimal representation of this integer.
             * @returns Hexadecimal representation of this integer.
             */
            toHexString(): string;
            /**
             * Raises this integer to the given exponent.
             *
             * @param exponent - Non-negative exponent in [0,2^30-1].
             * @returns Power of this integer.
             */
            pow(exponent: int32_t): LI;
            /**
             * Converts this integer to a string in the given radix. Negative
             * integers are indicated by a leading "-" character. The alphabet
             * for each digit is defined by the JavaScript Number.toString()
             * method for radix in [2,36]. Use LIE.toRadix() and your own
             * alphabet for converting to strings with larger radix.
             *
             * @param rx - Integer radix in [2,36], defaults to 10.
             * @returns Integer as an array of digits in small endian order in
             * the given radix, possibly with a leading "-" for negative integers.
             */
            toString(radix ? : int32_t): string;
            /**
             * Representation of zero.
             */
            static ZERO: LI;
            /**
             * Representation of one.
             */
            static ONE: LI;
            /**
             * Representation of two.
             */
            static TWO: LI;
        }
        /**
         * Pre-computes values to be used for simultaneous exponentiation for
         * a given list b of k bases and a modulus m. The method {@link
         * ModPowProd.modPowProd} then takes a list of exponents e and outputs
         * the modular power product
         *
         * <p>
         *
         * g[0] ^ e[0] * ... * g[k - 1] ^ e[k - 1] mod m.
         *
         * <p>
         *
         * The number of exponents must match the number of bases for which
         * pre-computation is performed.
         */
        class ModPowProd {
            static maxWidth: size_t;
            noBases: size_t;
            width: size_t;
            t: uli_t[][];
            modulus: LI;
            /**
             * Creates a table for the given bases, modulus, and width.
             *
             * @param bases - List of bases.
             * @param modulus - Modulus.
             * @param width - Width of each subtable.
             */
            constructor(bases: LI[], modulus: LI, width: size_t);
            /**
             * Computes a power-product using the given exponents.
             *
             * @param exponents - Exponents.
             * @returns Power product.
             */
            modPowProd(exponents: LI[]): LI;
        }
        /**
         * Fixed-basis exponentiation based on simultantaneous
         * exponentiation with exponent slicing.
         *
         * @param basis - Basis.
         * @param modulus - Modulus.
         * @param size - Expected number of exponentiations to compute.
         * @param width - If given this determines the width of the pre-computed
         * table, and otherwise it is chosen theoretically optimally.
         */
        class FixModPow {
            sliceSize: size_t;
            mpp: ModPowProd;
            constructor(basis: LI, modulus: LI, size: size_t, width ? : size_t);
            /**
             * Cuts an input integer into the appropriate number of
             * slices and outputs a list of integers such that the ith bit belongs
             * to the ith slice.
             *
             * @param exponent - Exponent.
             * @returns Array of exponents.
             */
            slice(exponent: LI): LI[];
            /**
             * Raises the fixed basis to the given exponent given the
             * fixed modulus.
             *
             * @param exponent - Exponent.
             * @returns Power of fixed basis to the given exponent.
             */
            modPow(exponent: LI): LI;
            /**
             * Takes the bit length of the exponents and the number
             * of exponentiations that we expect to compute and returns the
             * theoretically optimal width.
             *
             * @param bitLength - Expected bit length of exponents.
             * @param size - Expected number of exponentiations to compute.
             * @returns Theoretically optimal choice of width for the expected bit
             * length and number of exponentiations.
             */
            static optimalWidth(bitLength: size_t, size: size_t): size_t;
        }
        /**
         * Drop-in replacement for the BigInteger class of Tom Wu's JSBN
         * library.
         *
         * <p>
         *
         * This implements the functionality of the Java class
         * java.math.BigInteger from JDK 8 faithfully when possible at
         * all. The class verificatum.arithm.LIE may also be relevant for
         * encoding purposes. Bit operations and printing in different radix
         * is implemented in a simplistic slow way in some cases. We recommend
         * using VTS-BA to implement any algorithms.
         *
         * <p>
         *
         * The following methods appear in java.math.BigInteger JDK 8, but do
         * not make sense in TypeScript/JavaScript.
         *
         * <pre>
         * public static long BigInteger valueOf(long)
         * public float floatValue()
         * public long longValue()
         * public double doubleValue()
         * public int hashCode()
         * </pre>
         */
        class BigInteger {
            /**
             * Underlying instance of verificatum.arithm.LI.
             */
            li: LI;
            /**
             * The BigInteger constant zero.
             */
            static ZERO: BigInteger;
            /**
             * The BigInteger constant one.
             */
            static ONE: BigInteger;
            /**
             * The BigInteger constant ten.
             */
            static TEN: BigInteger;
            /**
             * Default number of repetitions of Miller-Rabin primality test.
             */
            static MILLER_RABIN_REPS: size_t;
            /**
             * Random source associated with this class.
             */
            static randomSource: RandomSource;
            /**
             * Initializes the random source of this instance. This has to be
             * set to use invoke isProbablePrime(), nextProbablePrime(), and
             * to use the constructor to generate a random prime.
             *
             * @param randomSource - Source of randomness.
             */
            static setRandomSource(randomSource: RandomSource): void;
            /**
             * Create a BigInteger wrapper of an instance of LI.
             *
             * @param s - Instance of LI.
             */
            constructor(li: LI);
            /**
             * Creates a non-negative integer from a raw array of bytes in
             * two's complement big endian representation.
             *
             * @param rawbytes - Array of words representing an non-negative
             * integer.
             */
            constructor(val: uint8_t[]);
            /**
             * Converts a string in the given radix to an instance of LI. The
             * alphabet is defined by the JavaScript Number.parseInt() method
             * for radix in [2,36]. Use LIE.toRadix(), your own alphabet, and
             * LI for converting strings with larger radix. Negative integers
             * start with a minus character. Leading zeros are ignored. By
             * default strings are assumed to be decimal strings.
             *
             * @param val - String to convert.
             * @param radix - Integer radix in [2,36].
             * @returns Integer as a sign value pair.
             */
            constructor(val: string, radix ? : radix_t);
            /**
             * Returns a random integer that is prime with probability at
             * least 1 - 2^certainty using Miller-Rabin primality test. The
             * static function setRandomSource() must be called before this
             * constructor.
             *
             * @param bitLength - Bit length of generated prime.
             * @param randomSource - Source of randomness.
             * @param certainty - Determines probability of accepting a composite.
             * @returns Random integer that is most likely prime.
             */
            constructor(bitLength: size_t, certainty: size_t, randomSource: RandomSource);
            /**
             * Creates an integer from a sign and array of words. A zero array
             * of {@link WORDSIZE}-bit words throws an error if the sign is
             * incorrect relative the words.
             *
             * @param sign - Sign of the integer.
             * @param value - Array of words representing a non-negative
             * integer in big endian order.
             */
            constructor(signum: sign_t, magnitude: uint8_t[]);
            /**
             * Samples a random non-negative integer of the given nominal bit
             * length, i.e., additional leading bits may be zero by chance.
             *
             * @param bitLength - Number of randomly chosen bits in the
             * sampled integer.
             * @param randomSource - Source of randomness.
             */
            constructor(bitLength: size_t, randomSource: RandomSource);
            /**
             * Returns the underlying instance of LI.
             */
            toLI(): LI;
            /**
             * Returns the sign of this integer.
             *
             * @returns Signum of this integer.
             */
            signum(): sign_t;
            /**
             * Returns the absolute value of this integer.
             *
             * @returns Absolute value of this integer.
             */
            abs(): BigInteger;
            /**
             * Returns negative of this integer.
             *
             * @returns -this.
             */
            negate(): BigInteger;
            /**
             * Computes sum of this integer and the input.
             *
             * @param term - Other integer.
             * @returns this + term.
             */
            add(term: BigInteger): BigInteger;
            /**
             * Computes difference of this integer and the input.
             *
             * @param term - Other integer.
             * @returns this - term.
             */
            subtract(term: BigInteger): BigInteger;
            /**
             * Computes product of this integer and the input.
             *
             * @param factor - Other integer.
             * @returns this * term.
             */
            multiply(factor: BigInteger): BigInteger;
            /**
             * Returns [q, r] such that q = this / divisor + r with
             * this / divisor and r rounded with sign, in particular, if divisor
             * is positive, then 0 <= r < divisor.
             *
             * @param divisor - Non-zero divisor.
             * @returns Quotient and divisor.
             */
            divideAndRemainder(divisor: BigInteger): [BigInteger, BigInteger];
            /**
             * Computes the integer quotient of this integer and the
             * input. See divideAndRemainder().
             *
             * @param divisor - Integer divisor.
             * @returns this / divisor for integers with rounding
             * according to signs.
             */
            divide(divisor: BigInteger): BigInteger;
            /**
             * Computes integer remainder of this integer divided by the
             * input. The remainder may be negative when the parameters have
             * different signs. See divideAndRemainder().
             *
             * @param divisor - Non-zero divisor.
             * @returns Integer remainder.
             */
            remainder(divisor: BigInteger): BigInteger;
            /**
             * Computes integer remainder of this integer divided by
             * the input as a value in [0, modulus - 1].
             *
             * @param modulus - Positive modulus.
             * @returns Integer remainder.
             */
            mod(modulus: BigInteger): BigInteger;
            /**
             * Raises this integer to the given exponent.
             *
             * @param exponent - Non-negative exponent.
             * @returns Power of this integer.
             */
            pow(exponent: int32_t): BigInteger;
            /**
             * Computes modular inverse of this integer modulo the input
             * modulus, which must be relative prime to this integer.
             *
             * @param modulus - Modulus.
             * @returns Integer x such that x * this = 1 mod modulus, where 0
             * <= x < modulus.
             */
            modInverse(modulus: BigInteger): BigInteger;
            /**
             * Computes modular power of this integer raised to the exponent
             * modulo the given modulus. The modulus must be non-negative and
             * this must either be non-negative or relatively prime with the
             * modulus.
             *
             * @param exponent - Exponent.
             * @param modulus - Integer greater than one.
             * @returns this^exponent mod modulus for positive integers.
             */
            modPow(exponent: BigInteger, modulus: BigInteger): BigInteger;
            /**
             * Computes greatest common divisor.
             *
             * @param other - Other integer.
             * @returns Greatest common divisor of this integer and the input.
             */
            gcd(other: BigInteger): BigInteger;
            /**
             * Returns true or false depending on if this integer is likely to
             * be a prime or not, determined using Miller-Rabins primality
             * test with the given number of
             * repetitions. BigInteger.setRandomSource must be called before
             * using this method.
             *
             * @param certainty - Repetitions of Miller-Rabins test.
             * @returns True or false depending on if this integer is likely to
             * be a prime or not.
             */
            isProbablePrime(certainty: size_t): boolean;
            /**
             * Returns true or false depending on if this integer is likely
             * to be a prime or not, determined using Miller-Rabins primality
             * test with the given number of repetitions.
             *
             * @param certainty - Repetitions of Miller-Rabins test.
             * @param randomSource - Source of randomness.
             * @returns True or false depending on if this integer is likely to
             * be a prime or not.
             */
            isProbablePrime(certainty: size_t, randomSource: RandomSource): boolean;
            /**
             * Returns the smallest integer greater than the absolute value of
             * this integer that that passes the Miller-Rabin primality test
             * with BigInteger.MILLER_RABIN_REPS repetitions.
             *
             * @returns the first integer greater than this BigInteger that is
             * probably prime.
             * @throws ArithmeticException - this < 0.
             */
            nextProbablePrime(): BigInteger;
            /**
             * Compares this integer with the input.
             *
             * @param other - Other integer.
             * @returns -1, 0, or 1 depending on if this integer is smaller than,
             * equal to, or greater than the input.
             */
            compareTo(other: BigInteger): sign_t;
            /**
             * Checks if this integer is equal to the input.
             *
             * @param other - Other integer.
             * @returns true if and only if this integer equals the input.
             */
            equals(other: BigInteger): boolean;
            /**
             * Returns the minimum of this integer and the input or this
             * integer if they are equal.
             *
             * @param other - Other integer.
             * @returns Minimum of this integer and the input.
             */
            min(other: BigInteger): BigInteger;
            /**
             * Returns the maximum of this integer and the input or this
             * integer if they are equal.
             *
             * @param other - Other integer.
             * @returns Maximum of this integer and the input.
             */
            max(other: BigInteger): BigInteger;
            /**
             * Returns the String representation of this BigInteger in the
             * given radix. If the radix is outside the range from
             * Character.MIN_RADIX to Character.MAX_RADIX (inclusive), it will
             * default to 10 (as is the case for Integer.toString). The
             * digit-to-character mapping provided by Character.forDigit is
             * used, and a minus sign is prepended if appropriate. (This
             * representation is compatible with the (String, int)
             * constructor.)
             *
             * @param radix - radix of the String representation.
             * @returns String representation of this BigInteger in the given
             * radix.
             * @see Integer.toString(int, int32_t), Character.forDigit(int, int32_t),
             * BigInteger(java.lang.String, int32_t)
             */
            toString(radix: radix_t): string;
            /**
             * Returns this integer in big endian two's complement
             * representation, i.e., the most significant byte appears last
             * and has a leading signum bit.
             *
             * @returns Byte array representation of this integer.
             */
            toByteArray(): uint8_t[];
            /**
             * Returns the 32 least significant bits of this integer in two's
             * complement.
             *
             * @returns The 32 least significant bits of this integer in two's
             */
            intValue(): int32_t;
            /**
             * This integer as a 16-bit signed integer.
             *
             * @returns This integer as a 16-bit signed integer.
             */
            shortValue(): int16_t;
            /**
             * This integer as a 32-bit signed integer represented as a
             * JavaScript number.
             *
             * @returns This integer as a 32-bit signed integer represented as a
             * JavaScript number.
             */
            byteValue(): int8_t;
            /**
             * Shifts this integer to the left. A negative offset shifts the
             * absolute value to the left.
             *
             * @param offset - Bit positions to shift.
             * @returns This integer shifted the given number of bits to the left.
             */
            shiftLeft(offset: int32_t): BigInteger;
            /**
             * Shifts this integer to the right. A negative offset shifts the
             * absolute value to the left.
             *
             * @param offset - Bit positions to shift.
             * @returns This integer shifted the given number of bits to the right.
             */
            shiftRight(offset: int32_t): BigInteger;
            /**
             * Returns the bitwise AND of this integer and the input.
             *
             * @param other - Other integer.
             * @returns Bitwise AND of this integer and the input.
             */
            and(other: BigInteger): BigInteger;
            /**
             * Returns the bitwise OR of this integer and the input.
             *
             * @param other - Other integer.
             * @returns Bitwise OR of this integer and the input.
             */
            or(other: BigInteger): BigInteger;
            /**
             * Returns the bitwise XOR of this integer and the input.
             *
             * @param other - Other integer.
             * @returns Bitwise XOR of this integer and the input.
             */
            xor(other: BigInteger): BigInteger;
            /**
             * Returns the bitwise complement of this integer.
             *
             * @param other - Other integer.
             * @returns Bitwise complement of this integer.
             */
            not(): BigInteger;
            /**
             * Syntactic sugar for this.and(other.not()).
             *
             * @param other - Other integer.
             * @returns Bitwise and of this integer and the complement of the
             * input.
             */
            andNot(other: BigInteger): BigInteger;
            /**
             * Returns true if the bit is set and false otherwise.
             *
             * @param index Index of bit.
             * @returns The bit as a boolean.
             */
            testBit(index: size_t): boolean;
            /**
             * Sets the bit at the given index.
             *
             * @parameter index - Index.
             */
            setBit(index: size_t): BigInteger;
            /**
             * Clears the bit at the given index.
             *
             * @parameter index - Index.
             */
            clearBit(index: size_t): BigInteger;
            /**
             * Returns a BigInteger whose value is equivalent to this BigInteger
             * with the designated bit flipped. (Computes (this ^ (1<<n)).)
             *
             * @param n - index of bit to flip.
             * @returns this ^ (1<<n)
             * @throws ArithmeticException - n is negative.
             */
            flipBit(index: size_t): BigInteger;
            /**
             * Returns the index of the least significant set bit or -1 if
             * this integer is zero.
             *
             * @returns Index of the least significant set bit or -1 if
             * this integer is zero
             */
            getLowestSetBit(): size_t;
            /**
             * Bit length of this integer in two's complement excluding sign
             * bit.
             *
             * @returns Bit length of this integer.
             */
            bitLength(): size_t;
            /**
             * Returns the number of bits in the two's complement
             * representation of this integer that differs from the sign
             * bit. This is the Hamming weight for non-negative numbers.
             *
             * @returns Number of bits in the two's complement
             * representation of this integer that differs from the sign
             * bit.
             */
            bitCount(): size_t;
            /**
             * Clones this integer.
             *
             * @returns Clone of this integer.
             */
            clone(): BigInteger;
            /**
             * Computes modular power of this integer raised to the exponent
             * modulo the given modulus. This integer must be non-negative.
             *
             * @param exponent - Non-negative exponent.
             * @param modulus - Integer greater than one.
             * @returns this^exponent mod modulus for positive integers.
             */
            modPowInt(exponent: int32_t, modulus: BigInteger): BigInteger;
        }
    }
}
//# sourceMappingURL=vts-ba-1.1.0-p30.d.ts.map